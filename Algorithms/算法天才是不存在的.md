筑基篇:
	一般数据结构:
		[[列表（List Array list Array等）]]
		- append一个元素、pop末尾元素均为O（1）
		- 查找某个元素的索引O（n）
	
		[[哈希（hash table）]]
		- 什么是哈希，哈希函数是什么，最常见的哈希表数据结构是什么（集合与哈希表）
		- 集合（set/ hashset等）。
		- 集合一般用于干什么？
		- 集合的常见操作有哪些？每个常见操作的时间复杂度是什么？
		- 哈希表（Hashmap/ dict/ unordered_map等）。
		- 哈希表一般用于干什么？
		- 哈希表有哪些常见操作？对应的时间复杂度，空间复杂度分别是什么？
	
		[[栈（stack）]]
		- 什么是栈？什么是后进先出？
		- 栈一般用于解决什么问题？
		- 什么是程序栈？
		- 你所熟悉的语言当中栈是用什么数据结构实现的？（Python当中用list就可以代表栈）
	
		[[队列（queue）]]
		- 什么是队列？什么是先进先出？
		- 队列一般应用在哪些场景当中？
		- 什么是消息队列？
		- 你所熟悉的语言当中栈是用什么数据结构实现的？（Python当中可以用deque或者queue）
	
		[[堆（heap）]]
		- 什么是堆？什么是最大堆、最小堆？
		- 堆一般用于解决什么问题？ 
		- 你所熟悉的语言当中堆是用什么数据结构实现的？（Python当中堆用的是列表实现的，并且Python只有最小堆没有最大堆）
	高级数据结构：
		[[链表（linked list）]]
		- 链表的节点（node）是如何实现的？
		- 如何创建一个链表？
		- 如何遍历一个链表？
		- 如何在链表中查找一个元素是否存在？
		- 如何在链表中添加/删除一个元素？
	
		[[二叉树（binary tree）]]
		- 二叉树的节点（node）是如何实现的？
		- 如何创建一个二叉树？
		- 如何遍历一个链表？何谓二叉树的层序、前序、中序、后序遍历？
	
		[[二叉搜索树（二叉查找树、binary search tree、BST）]]
		- 与普通的二叉树相比，二叉搜索树特点是什么？如何证明一棵二叉树是/不是一课二叉搜索树？
		- 一个二叉树是二叉搜索树 <-> 该二叉树的中序遍历是单调递增的
	
		[[简单图（graph）]]
		- 什么是图？什么是有向图（directed graph）？什么是无向图（undirected graph）？
		- 图与树的关系是？如何知道一个图是不是一课树？
		- 如何实现一个简单图？
	入门算法：
		[[递归（recursion）]]
		- 什么是递归？
		- 递归的优势、劣势是什么？
		- 递归三要素是什么？
	
		[[排序算法（sort）]]
		- 快速排序如何实现？时间/空间复杂度是多少？
		- 归并排序如何实现？时间/空间复杂度是多少？
	
		[[Algorithms/基础概念/入门算法/二分法（Binary Search）|二分法（Binary Search）]]
		- 二分法的基本原理是什么？
		- 二分法一般用于解决什么问题？
		- 二分法的时间复杂度是什么？
	
		[[宽度优先遍历（宽度优先搜索、Breadth first search、BFS）]]
		- 宽度优先遍历的模板是什么？
		- 宽度优先遍历的时间/空间复杂度是什么？
		- 宽度优先遍历一颗二叉树与一个图的区别在哪？
		- 宽度优先遍历一般用于解决什么问题？
	
		[[深度优先遍历（深度优先搜索、Depth first search、DFS）]]
		- 深度优先遍历的模板是什么？
		- 深度优先遍历的时间/空间复杂度是什么？
		- 深度优先遍历一颗二叉树与一个图的区别在哪？
		- 深度优先遍历一般用于解决什么问题？

闭关刷题篇：

	[[排序类（Sort）]]
	- 基础知识：快速排序（Quick Sort）， 归并排序（Merge Sort）的原理与代码实现。需要能讲明白代码中每一行的目的。快速排序时间复杂度平均状态下O（NlogN），空间复杂度O（1），归并排序最坏情况下时间复杂度O（NlogN），空间复杂度O（N）

	[[链表类（Linked List）]]
	- 基础知识：链表如何实现，如何遍历链表。链表可以保证头部尾部插入删除操作都是O（1），查找任意元素位置O（N）
	
	[[堆（Heap or Priority Queue）、栈（Stack）、队列（Queue）、哈希表类（Hashmap、Hashset）]]
	- 基础知识：各个数据结构的基本原理，增删查改复杂度。
	
	[[二分法（Binary Search）]]
	- 二分法是用来解法基本模板，时间复杂度logN；常见的二分法题目可以分为两大类，显式与隐式，即是否能从字面上一眼看出二分法的特点：要查找的数据是否可以分为两部分，前半部分为X，后半部分为O

	[[双指针（2 Pointer）]]
	- 常见双指针算法分为三类，同向（即两个指针都相同一个方向移动），背向（两个指针从相同或者相邻的位置出发，背向移动直到其中一根指针到达边界为止），相向（两个指针从两边出发一起向中间移动直到两个指针相遇）

	[[宽度优先搜索（BFS）]]
	- 常见的DFS用来解决什么问题？(1) 图中（有向无向皆可）的符合某种特征（比如最长）的路径以及长度（2）排列组合（3） 遍历一个图（或者树）（4）找出图或者树中符合题目要求的全部方案
	- DFS基本模板（需要记录路径，不需要返回值 and 不需要记录路径，但需要记录某些特征的返回值）
	- 除了遍历之外多数情况下时间复杂度是指数级别，一般是O(方案数×找到每个方案的时间复杂度)
	- 递归题目都可以用非递归迭代的方法写，但一般实现起来非常麻烦

	[[深度优先搜索（DFS）]]
	- 常见的DFS用来解决什么问题？(1) 图中（有向无向皆可）的符合某种特征（比如最长）的路径以及长度（2）排列组合（3） 遍历一个图（或者树）（4）找出图或者树中符合题目要求的全部方案
	- DFS基本模板（需要记录路径，不需要返回值 and 不需要记录路径，但需要记录某些特征的返回值）
	- 除了遍历之外多数情况下时间复杂度是指数级别，一般是O(方案数×找到每个方案的时间复杂度)
	- 递归题目都可以用非递归迭代的方法写，但一般实现起来非常麻烦

	[[前缀和（Prefix Sum）]]
	- 前缀和本质上是在一个list当中，用O（N）的时间提前算好从第0个数字到第i个数字之和，在后续使用中可以在O（1）时间内计算出第i到第j个数字之和，一般很少单独作为一道题出现，而是很多题目中的用到的一个小技巧

	[[并查集（Union Find）]]
	- 如果数据不是实时变化，本类问题可以用BFS或者DFS的方式遍历，如果数据实时变化（data stream）则并查集每次的时间复杂度可以视为O（1）；需要牢记合并与查找两个操作的模板

	[[字典树（Trie）]]
	- [Trie - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/Trie)
	- 多数情况下可以通过用一个set来记录所有单词的prefix来替代，时间复杂度不变，但空间复杂度略高

	[[单调栈与单调队列（Monotone Stack／Queue）]]
	- 单调栈一般用于解决数组中找出每个数字的第一个大于／小于该数字的位置或者数字；单调队列只见过一道题需要使用；不论单调栈还是单调队列，单调的意思是保留在栈或者队列中的数字是单调递增或者单调递减的

	[[扫描线算法（Sweep Line）]]
	- 一个很巧妙的解决时间安排冲突的算法，本身比较容易些也很容易理解

	[[树状图（TreeMap）]]
	- 基于红黑树（平衡二叉搜索树）的一种树状 hashmap，增删查改、找求大最小均为logN复杂度，Python当中可以使用SortedDict替代；SortedDict继承了普通的dict全部的方法，除此之外还可以peekitem(k)来找key里面第k大的元素，popitem(k)来删除掉第k大的元素，弥补了Python自带的heapq没法logN时间复杂度内删除某个元素的缺陷；最近又在刷一些hard题目时候突然发现TreeMap简直是个神技，很多用别的数据结构写起来非常麻烦的题目，TreeMap解决起来易如反掌。

	[[动态规划（Dynamic Programming）]]
	- 这里指的是用for循环方式的动态规划，非Memoization Search方式。DP可以在多项式时间复杂度内解决DFS需要指数级别的问题。常见的题目包括找最大最小，找可行性，找总方案数等，一般结果是一个Integer或者Boolean。

