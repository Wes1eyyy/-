### MergeSort (归并排序)
[归并排序 | 菜鸟教程](https://www.runoob.com/data-structures/merge-sort.html)

归并排序是一种分而治之的算法，它将原始数组分成两半，分别对每一半进行排序，然后将两个排序好的半部分合并在一起。归并排序中的关键过程是两个有序序列的合并。

**时间复杂度:** 归并排序的时间复杂度在最好、平均和最坏情况下都是 O(nlogn)，其中 n 是数组的长度。这是因为归并排序总是均匀地将数组分成两半，并且合并操作是线性的。

**空间复杂度:** 归并排序的空间复杂度是 O(n)，主要用于存储在合并过程中的临时数组。这意味着归并排序不是原地排序算法。

### Elementary Sort (基本排序算法)
[冒泡排序 | 菜鸟教程](https://www.runoob.com/w3cnote/bubble-sort.html)
[选择排序 | 菜鸟教程](https://www.runoob.com/w3cnote/selection-sort.html)
[插入排序 | 菜鸟教程](https://www.runoob.com/data-structures/insertion-sort.html)

基本排序算法指的是那些易于理解和实现但可能对大数据集效率不高的简单排序算法。包括冒泡排序、选择排序和插入排序等。

- **冒泡排序:** 重复遍历列表，比较相邻元素，并在顺序错误时交换它们。该过程重复，直到列表排序完成。
- **选择排序:** 从数组的未排序部分找到最小元素，并将其与未排序部分开头的元素交换。
- **插入排序:** 通过一次一个元素地重复从未排序部分取出一个元素并将其插入到排序部分的正确位置中，从而构建最终的排序数组。

**时间复杂度:** 最好情况 O(n)（已经排序的数组），平均和最坏情况 O(n^2)。 
**空间复杂度:** O(1)，原地排序。

### QuickSort (快速排序)
[快速排序 | 菜鸟教程](https://www.runoob.com/w3cnote/quick-sort.html)

快速排序是一种高效的排序算法，与归并排序一样，遵循分而治之的原则。它选择一个元素作为枢轴，并围绕这个枢轴对给定数组进行划分。关键过程是划分。

**时间复杂度:** 平均情况下，快速排序的时间复杂度是 O(nlogn)。最坏情况（枢轴的选择不幸每次都是最大或最小元素）的时间复杂度是 O(n^2)。然而，通过使用随机化版本的快速排序，最坏情况的发生概率可以大大降低。

**空间复杂度:** 快速排序的空间复杂度取决于递归调用的深度，最好情况是 O(logn)，最坏情况（不平衡的划分）是 O(n)。

### HeapSort (堆排序)
[堆排序 | 菜鸟教程](https://www.runoob.com/w3cnote/heap-sort.html)

堆排序是一种基于比较的排序算法，使用二叉堆数据结构。它从输入数据中构建一个最大堆，然后重复从堆中提取最大元素并重建堆，直到所有元素都被排序。

**时间复杂度:** 堆排序在所有情况下的时间复杂度都是 O(nlogn)，因为构建初始堆的时间复杂度是 O(n)，之后有 n−1 次调整堆的操作，每次调整的时间复杂度是 O(logn)。

**空间复杂度:** O(1)，堆排序是原地排序算法，不需要额外的存储空间。